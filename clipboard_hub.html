<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NemOS - Clipboard Hub</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <style>
        @import url('https://rsms.me/inter/inter.css');
        body { font-family: 'Inter', sans-serif; }
        
        /* Custom scrollbar for desktop */
        @media (hover: hover) and (pointer: fine) {
            ::-webkit-scrollbar {
                width: 8px;
                height: 8px;
            }
            ::-webkit-scrollbar-track {
                background: #1f2937; /* bg-gray-800 */
            }
            ::-webkit-scrollbar-thumb {
                background: #4b5563; /* bg-gray-600 */
                border-radius: 4px;
            }
            ::-webkit-scrollbar-thumb:hover {
                background: #6b7280; /* bg-gray-500 */
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 p-4 h-screen flex flex-col">
    <header class="mb-4">
        <h1 class="text-2xl font-bold">Clipboard Hub</h1>
        <p id="user-id-display" class="text-xs text-gray-500 font-mono">Connecting...</p>
    </header>

    <div class="flex flex-col sm:flex-row sm:items-center space-y-2 sm:space-y-0 sm:space-x-2 mb-4">
        <input id="new-item-content" type="text" placeholder="Add new item to history..." class="w-full bg-gray-800 border border-gray-700 rounded-lg px-4 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
        <button id="add-item-btn" class="w-full sm:w-auto px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition-colors">Add</button>
    </div>

    <div class="flex flex-col sm:flex-row sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
        <div class="relative flex-grow w-full">
            <svg class="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
            <input id="search-bar" type="text" placeholder="Search history..." class="w-full bg-gray-800 border border-gray-700 rounded-lg pl-10 pr-4 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
        </div>
         <button id="clear-untagged-btn" class="w-full sm:w-auto px-3 py-2 bg-red-800 text-white font-semibold rounded-lg hover:bg-red-900 transition-colors text-sm flex-shrink-0" title="Delete all items that are not tagged and not pinned">
            Clear Untagged
        </button>
        <button id="reorder-btn" class="w-full sm:w-auto px-3 py-2 bg-gray-600 text-white font-semibold rounded-lg hover:bg-gray-700 transition-colors text-sm flex-shrink-0" title="Toggle drag-and-drop reordering">
            Reorder
        </button>
    </div>
    
    <div id="tabs-container" class="flex flex-wrap gap-2 mb-4">
        <!-- Tabs will be injected here -->
    </div>

    <main id="history-list" class="flex-grow space-y-3 overflow-y-auto pr-2">
        <!-- Clipboard items will be injected here -->
    </main>
    
    <!-- Tag Editor Modal -->
    <div id="tag-modal" class="fixed inset-0 z-50 modal-backdrop hidden items-center justify-center p-4">
        <div class="modal-content w-full max-w-lg bg-gray-800 p-6 rounded-lg shadow-xl">
            <h3 id="tag-modal-title" class="text-lg font-bold mb-4">Edit Tags</h3>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-400 mb-2">Click to add/remove existing tags:</label>
                <div id="existing-tags-container" class="flex flex-wrap gap-2"></div>
            </div>
            <div>
                 <label for="tag-input" class="block text-sm font-medium text-gray-400 mb-2">Or type new tags (comma separated):</label>
                 <input id="tag-input" type="text" class="w-full bg-gray-900 rounded p-2 border border-gray-600">
            </div>
            <div class="mt-6 flex justify-end space-x-2">
                <button id="cancel-tag-btn" class="px-4 py-2 bg-gray-600 rounded-lg hover:bg-gray-700">Cancel</button>
                <button id="save-tag-btn" class="px-4 py-2 bg-blue-600 rounded-lg hover:bg-blue-700">Save</button>
            </div>
        </div>
    </div>
    
    <!-- NemOS Libraries -->
    <script src="ux_console.js"></script>
    
    <script>
        // --- CONFIG & INITIALIZATION ---
        const API_BASE_URL = '/api/clipboard';

        // --- DOM Elements ---
        const userIdDisplay = document.getElementById('user-id-display');
        const newItemContent = document.getElementById('new-item-content');
        const addItemBtn = document.getElementById('add-item-btn');
        const historyList = document.getElementById('history-list');
        const searchBar = document.getElementById('search-bar');
        const tabsContainer = document.getElementById('tabs-container');
        const clearUntaggedBtn = document.getElementById('clear-untagged-btn');
        const reorderBtn = document.getElementById('reorder-btn');
        // Tag Modal
        const tagModal = document.getElementById('tag-modal');
        const tagModalTitle = document.getElementById('tag-modal-title');
        const existingTagsContainer = document.getElementById('existing-tags-container');
        const tagInput = document.getElementById('tag-input');
        const saveTagBtn = document.getElementById('save-tag-btn');
        const cancelTagBtn = document.getElementById('cancel-tag-btn');
        let currentEditingItemId = null;

        // --- STATE ---
        let clipboardItems = [];
        let allTags = new Set();
        let filterText = '';
        let activeTab = 'All';
        let sortableInstance = null;

        // --- INITIAL LOAD ---
        document.addEventListener('DOMContentLoaded', () => {
            userIdDisplay.textContent = 'Storage: Local SQLite';
            fetchItems();
            
            // Initialize SortableJS for drag-and-drop
            sortableInstance = new Sortable(historyList, {
                animation: 150,
                ghostClass: 'bg-gray-700',
                disabled: true, // Disabled by default
                onEnd: function (evt) {
                    const orderedIds = Array.from(historyList.children).map(child => child.dataset.id);
                    saveOrder(orderedIds);
                }
            });
        });
        
        reorderBtn.addEventListener('click', () => {
            const isDisabled = sortableInstance.option('disabled');
            sortableInstance.option('disabled', !isDisabled);

            if (isDisabled) {
                reorderBtn.textContent = 'Done';
                reorderBtn.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                reorderBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                historyList.classList.add('reordering-active'); // For potential styling
                 NemOS.feedback.showToast('Reordering enabled.', 'info');
            } else {
                reorderBtn.textContent = 'Reorder';
                reorderBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                reorderBtn.classList.add('bg-gray-600', 'hover:bg-gray-700');
                historyList.classList.remove('reordering-active');
                 NemOS.feedback.showToast('Reordering disabled.', 'info');
            }
        });
        
        async function saveOrder(orderedIds) {
            try {
                await apiRequest('/reorder', 'POST', { orderedIds });
                console.log('Order saved!');
                // No need to call fetchItems() as the visual order is already correct.
                // The backend is now in sync.
            } catch (error) {
                NemOS.feedback.showToast('Failed to save order.', 'error');
                // If saving fails, we should probably revert the list to its original state
                // by calling fetchItems() to show the last saved order.
                fetchItems();
            }
        }
        
        // --- API HELPER ---
        async function apiRequest(endpoint, method = 'GET', body = null) {
            try {
                const options = {
                    method,
                    headers: { 'Content-Type': 'application/json' }
                };
                if (body) {
                    options.body = JSON.stringify(body);
                }
                const response = await fetch(`${API_BASE_URL}${endpoint}`, options);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'API request failed');
                }
                return response.status === 204 ? null : await response.json();
            } catch (error) {
                console.error(`API Error (${method} ${endpoint}):`, error);
                NemOS.feedback.showToast(error.message, 'error');
                throw error; // Re-throw to stop subsequent actions
            }
        }

        // --- DATABASE OPERATIONS ---
        async function fetchItems() {
            const items = await apiRequest('/items');
            clipboardItems = items;
            const tagSet = new Set();
            clipboardItems.forEach(item => item.tags.forEach(tag => tagSet.add(tag)));
            allTags = tagSet;
            render();
        }

        async function addItem(content) {
            if (!content.trim()) return;
            const newItem = {
                id: `clip-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                content: content,
                createdAt: Date.now(),
                tags: [],
                isPinned: false
            };
            await apiRequest('/items', 'POST', newItem);
            fetchItems(); // Refresh list
        }

        async function updateItem(itemId, data) {
            await apiRequest(`/items/${itemId}`, 'PUT', data);
            fetchItems(); // Refresh list
        }

        async function deleteItem(itemId) {
             NemOS.feedback.confirm('Delete Item?', 'This action cannot be undone.', async () => {
                await apiRequest(`/items/${itemId}`, 'DELETE');
                NemOS.feedback.showToast('Item deleted.', 'info');
                fetchItems(); // Refresh list
            });
        }
        
        async function deleteUntaggedItems() {
             const itemsToDelete = clipboardItems.filter(item => item.tags.length === 0 && !item.isPinned);
             if (itemsToDelete.length === 0) {
                 NemOS.feedback.showToast('No untagged items to clear.', 'info');
                 return;
             }
             NemOS.feedback.confirm(
                `Clear ${itemsToDelete.length} items?`,
                'This will permanently delete all un-tagged and un-pinned items.',
                async () => {
                    await apiRequest('/clear-untagged', 'POST');
                    NemOS.feedback.showToast(`${itemsToDelete.length} items cleared.`, 'success');
                    fetchItems();
                }
            );
        }

        // --- RENDERING & UI ---
        function render() {
            renderTabs();
            
            const lowerFilter = filterText.toLowerCase();
            const filteredItems = clipboardItems.filter(item => {
                const contentMatch = item.content.toLowerCase().includes(lowerFilter);
                const tagMatch = item.tags.some(tag => tag.toLowerCase().includes(lowerFilter));
                const tabMatch = activeTab === 'All' || item.tags.includes(activeTab);
                return (contentMatch || tagMatch) && tabMatch;
            });
            
            const pinned = filteredItems.filter(item => item.isPinned);
            const unpinned = filteredItems.filter(item => !item.isPinned);

            historyList.innerHTML = '';
            pinned.forEach(item => historyList.appendChild(createItemCard(item)));
            unpinned.forEach(item => historyList.appendChild(createItemCard(item)));
        }

        function renderTabs() {
            tabsContainer.innerHTML = '';
            const tabs = ['All', ...Array.from(allTags).sort()];
            tabs.forEach(tag => {
                const tab = document.createElement('button');
                tab.className = `tab px-3 py-1 text-sm rounded-md transition-colors ${activeTab === tag ? 'bg-blue-600 text-white' : 'bg-gray-700 hover:bg-gray-600'}`;
                tab.textContent = tag;
                tab.dataset.tab = tag;
                tabsContainer.appendChild(tab);
            });
        }
        
        function createItemCard(item) {
            const card = document.createElement('div');
            card.className = `item-card bg-gray-800 p-3 rounded-lg flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4 border-2 ${item.isPinned ? 'border-blue-500' : 'border-transparent'}`;
            card.dataset.id = item.id; // Add item ID to the element

            const contentEl = document.createElement('div');
            contentEl.className = 'flex-grow min-w-0';
            
            const textPreview = document.createElement('pre');
            textPreview.className = 'text-sm whitespace-pre-wrap font-mono text-gray-300 break-words';
            textPreview.textContent = item.content;

            const tagsEl = document.createElement('div');
            tagsEl.className = 'flex flex-wrap gap-1 mt-2';
            item.tags.forEach(tag => {
                const tagSpan = document.createElement('span');
                tagSpan.className = 'text-xs bg-gray-700 px-2 py-1 rounded-full';
                tagSpan.textContent = tag;
                tagsEl.appendChild(tagSpan);
            });
            
            contentEl.appendChild(textPreview);
            if(item.tags.length > 0) contentEl.appendChild(tagsEl);
            
            card.appendChild(contentEl);

            const actionsEl = document.createElement('div');
            actionsEl.className = 'flex items-center space-x-2 flex-shrink-0 self-end mt-2 sm:self-auto sm:mt-0';
            
            const pinIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="${item.isPinned ? 'currentColor' : 'none'}" stroke-linecap="round" stroke-linejoin="round"><path d="M15 4.5l-4 4l-4 1.5l-1.5 1.5l7 7l1.5 -1.5l1.5 -4l4 -4" /><path d="M9 15l-4.5 4.5" /><path d="M14.5 4l5.5 5.5" /></svg>`;
            const tagIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></svg>`;
            const deleteIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-red-400 hover:text-red-300"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`;

            actionsEl.innerHTML = `
                <button class="pin-btn p-2 rounded-full hover:bg-gray-700 ${item.isPinned ? 'text-blue-400' : 'text-gray-400'}">${pinIcon}</button>
                <button class="tag-btn p-2 rounded-full hover:bg-gray-700 text-gray-400">${tagIcon}</button>
                <button class="delete-btn p-2 rounded-full hover:bg-gray-700">${deleteIcon}</button>
            `;

            card.appendChild(actionsEl);

            // Event Listeners
            contentEl.addEventListener('click', () => handleCopy(item.id, card));
            actionsEl.querySelector('.pin-btn').addEventListener('click', () => updateItem(item.id, { isPinned: !item.isPinned }));
            actionsEl.querySelector('.tag-btn').addEventListener('click', () => openTagModal(item.id));
            actionsEl.querySelector('.delete-btn').addEventListener('click', () => deleteItem(item.id));

            return card;
        }
        
        // --- EVENT LISTENERS & HANDLERS ---
        tabsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('tab')) {
                activeTab = e.target.dataset.tab;
                render();
            }
        });

        searchBar.addEventListener('input', (e) => {
            filterText = e.target.value;
            render();
        });

        addItemBtn.addEventListener('click', () => {
            addItem(newItemContent.value);
            newItemContent.value = '';
        });
        
        clearUntaggedBtn.addEventListener('click', deleteUntaggedItems);
        
        function handleCopy(itemId, cardElement) {
            const item = clipboardItems.find(i => i.id === itemId);
            if (!item) return;

            navigator.clipboard.writeText(item.content).then(() => {
                NemOS.feedback.showToast('Copied!', 'success');
            }, (err) => {
                NemOS.feedback.showToast('Failed to copy.', 'error');
                console.error('Copy failed: ', err);
            });
        }

        function openTagModal(itemId) {
            currentEditingItemId = itemId;
            const item = clipboardItems.find(i => i.id === currentEditingItemId);
            if (!item) return;

            tagModalTitle.textContent = `Edit Tags for: "${item.content.substring(0, 20)}..."`;
            
            // Populate existing tags for the item
            tagInput.value = item.tags.join(', ');

            // Populate all known tags for easy adding
            existingTagsContainer.innerHTML = '';
            Array.from(allTags).sort().forEach(tag => {
                const tagButton = document.createElement('button');
                tagButton.className = `px-2 py-1 text-xs rounded-full ${item.tags.includes(tag) ? 'bg-blue-600 text-white' : 'bg-gray-600 hover:bg-gray-500'}`;
                tagButton.textContent = tag;
                tagButton.dataset.tag = tag;
                existingTagsContainer.appendChild(tagButton);
            });
            tagModal.classList.remove('hidden');
        }

        existingTagsContainer.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                const tag = e.target.dataset.tag;
                const currentTags = new Set(tagInput.value.split(',').map(t => t.trim()).filter(Boolean));
                if (currentTags.has(tag)) {
                    currentTags.delete(tag);
                } else {
                    currentTags.add(tag);
                }
                tagInput.value = Array.from(currentTags).join(', ');
                e.target.classList.toggle('bg-blue-600');
                e.target.classList.toggle('text-white');
                e.target.classList.toggle('bg-gray-600');
            }
        });

        saveTagBtn.addEventListener('click', () => {
            const tags = tagInput.value.split(',').map(t => t.trim()).filter(Boolean);
            updateItem(currentEditingItemId, { tags: tags });
            tagModal.classList.add('hidden');
        });

        cancelTagBtn.addEventListener('click', () => {
            tagModal.classList.add('hidden');
        });
    </script>
</body>
</html>

